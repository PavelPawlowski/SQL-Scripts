/* *****************************************************************************************
                                      AZURE SQL DB Notice

   Comment-out the unsupported USE [master] when running in Azure SQL DB/Synapse Analytics
   or ignore error caused by unsupported USE statement
******************************************************************************************** */

USE [master]
GO
IF NOT EXISTS (SELECT 1 FROM sys.all_objects WHERE object_id = OBJECT_ID('[dbo].[sp_HelpPartitionFunction]') AND TYPE = 'P')
    EXECUTE ('CREATE PROCEDURE [dbo].[sp_HelpPartitionFunction] AS BEGIN PRINT ''Container for [dbo].[sp_HelpPartitionFunction] (C) Pavel Pawlowski'' END')
GO
/* *******************************************************
sp_HelpPartitionFunction v 0.53 (2018-03-20)

Feedback: mailto:pavel.pawlowski@hotmail.cz

MIT License

Copyright (c) 2017 Pavel Pawlowski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Description: 
    Provides information about the partition function including partitions it will generate and their boundary values
    Procedure also lists depended partition schemes and tables/indexed views/indexes using that partition function


Parameters:
     @pfName            nvarchar(128)   = NULL  --Name of the partition function
    ,@listDependencies  bit             = 0     --Specifies whether list dependencies of the partition function
    ,@noInfoMsg         bit             = 0     --Disbles printing of header and informationals messages

Result table schema:
CREATE TABLE #Results(
     [PartitionFunctionName] sysname         NOT NULL   --Partition function name
    ,[PartitionFunctionID]   int             NOT NULL   --Partition function id
    ,[Created]               datetime        NOT NULL   --Date/Time when the partition function was created
    ,[Modified]              datetime        NOT NULL   --Date/Time when the partition function was last modified
    ,[ParameterDataType]     sysname         NOT NULL   --data type of the partition function parameter
    ,[BoundaryType]          nvarchar(5)     NOT NULL   --Boundary type of the partition function LEFT/RIGHT
    ,[PartitionID]           bigint          NULL       --ID of the partition which will be generated by the partition function
    ,[LeftBoundaryIncluded]  char(1)         NOT NULL   --Specifies whether left boundary value is included in the partition
    ,[RightBoundaryIncluded] char(1)         NOT NULL   --Specifies whether right boundary value is included in the partition
    ,[LeftBoundary]          sql_variant     NULL       --Left boundary value
    ,[RightBoundary] [       sql_variant     NULL       --Right boundary value
    ,[PartitionRange]        nvarchar(4000)  NULL       --Partition range in human readable form
);
*/
ALTER PROCEDURE [dbo].[sp_HelpPartitionFunction]
     @pfName            nvarchar(128)   = NULL  --Name of the partition function
    ,@listDependencies  bit             = 0     --Specifies whether list dependencies of the partition function
    ,@noInfoMsg         bit             = 0     --Disbles printing of header and informational messages
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE
        @caption            nvarchar(max)        --Procedure caption
        ,@msg               nvarchar(max)        --message
        ,@pfID              int                 --ID of partition Function
        ,@partitionsCount   int                 --count of boundary values

    IF @noInfoMsg = 0
    BEGIN
        SET @caption = N'sp_HelpPartitionFunction v 0.53 (2018-03-20) (C) 2014 - 2018 Pavel Pawlowski' + NCHAR(13) + NCHAR(10) + 
                       N'============================================================================';
        RAISERROR(@caption, 0, 0) WITH NOWAIT;
    END

    --if partition function name is not provided, print Help
    IF @pfName IS NULL
    BEGIN
        RAISERROR(N'', 0, 0) WITH NOWAIT;
        RAISERROR(N'Provides detailed information about the partition function including partitions and their boundary values it will generate as well as dependencies.', 0, 0) WITH NOWAIT;
        RAISERROR(N'', 0, 0);
        RAISERROR(N'Usage:', 0, 0);
        RAISERROR(N'[sp_HelpPartitionFunction] {@pfName = ''partition_function_name''} [,@listDependencies]', 0, 0);
        RAISERROR(N'', 0, 0);
        SET @msg = N'Parameters:
     @pfName            nvarchar(128)   = NULL - Name of the partition function for which the information should be returned
    ,@listDependencies  bit             = 1    - Specifies whether list dependencies of the partition function';
        RAISERROR(@msg, 0, 0);

    SET @msg = N'
Table schema to hold results for partition information
------------------------------------------------------
CREATE TABLE #Results(
     [PartitionFunctionName] sysname         NOT NULL   --Partition function name
    ,[PartitionFunctionID]   int             NOT NULL   --Partition function id
    ,[Created]               datetime        NOT NULL   --Date/Time when the partition function was created
    ,[Modified]              datetime        NOT NULL   --Date/Time when the partition function was last modified
    ,[ParameterDataType]     sysname         NOT NULL   --data type of the partition function parameter
    ,[BoundaryType]          nvarchar(5)     NOT NULL   --Boundary type of the partition function LEFT/RIGHT
    ,[PartitionID]           bigint          NULL       --ID of the partition which will be generated by the partition function
    ,[LeftBoundaryIncluded]  char(1)         NOT NULL   --Specifies whether left boundary value is included in the partition
    ,[RightBoundaryIncluded] char(1)         NOT NULL   --Specifies whether right boundary value is included in the partition
    ,[LeftBoundary]          sql_variant     NULL       --Left boundary value
    ,[RightBoundary] [       sql_variant     NULL       --Right boundary value
    ,[PartitionRange]        nvarchar(4000)  NULL       --Partition range in human readable form
);';
        RAISERROR(@msg, 0, 0);

        RETURN
    END

    --Get the partition function ID and count of partitions it will generate
    SELECT
         @pfID              = pf.function_id
        ,@partitionsCount   = pf.fanout
    FROM sys.partition_functions pf
    WHERE pf.[name] = @pfName

    IF @pfID IS NULL
    BEGIN
        RAISERROR(N'Partition Function [%s] does not exists', 15, 0, @pfname) WITH NOWAIT;
        RETURN;
    END;

    IF @noInfoMsg = 0
        RAISERROR(N'Retrieving information for partition function [%s]', 0, 0, @pfName) WITH NOWAIT;

    --Get partition information
    WITH TallyBase AS ( --Bae Tally table for generating partition IDs
        SELECT
            N
        FROM (VALUES (1), (1), (1), (1), (1), (1), (1), (1), (1), (1)) T(N)  --10 rows
    ),
    [Partitions] AS (   --Generate partitions for the partition function
        SELECT TOP (@partitionsCount)   -- Get Only @boundariesCount +1 as this is the number of partitions
            ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS PartitionID
        FROM 
             TallyBase T10      --10 
            ,TallyBase T100     --100
            ,TallyBase T1000    --1000
            ,TallyBase T10000   --10000
            ,TallyBase T100000  --100000 --Enough for maximum number of partitions
    ),
    PartitionBaseData AS (  --Get partition data
        SELECT
            pf.[name]                                       AS PartitionFunctionName
            ,pf.function_id                                 AS PartitionFunctionID
            ,CASE WHEN boundary_value_on_right = 0 THEN N'LEFT' ELSE 'RIGHT' END AS BoundaryType
            ,pf.create_date                                 AS Created
            ,pf.modify_date                                 AS Modified
            ,p.PartitionID                                  AS PartitionID
            ,prv.[value]                                    AS LeftBoundary
            ,LEAD(prv.[value]) OVER(ORDER BY p.PartitionID) AS RightBoundary
            ,ISNULL (
                CASE ppt.[name] --Format the value for displaying
                    WHEN N'date' THEN LEFT(CONVERT(varchar(30), CONVERT(date, prv.[value] ), 120), 10)
                    WHEN N'datetime' THEN CONVERT(varchar(30), CONVERT(datetime, prv.[value] ), 121)
                    WHEN N'datetime2' THEN CONVERT(varchar(30), CONVERT(datetime2, prv.[value] ), 121)
                    ELSE CONVERT(varchar(30), prv.[value] )
                END
                , N''
            )                                               AS LeftBoundaryStr
            ,ISNULL (
                CASE ppt.[name] --Format the value for displaying
                    WHEN N'date' THEN CONVERT(varchar(30), LEFT(CONVERT(date, LEAD(prv.[value]) OVER(ORDER BY p.PartitionID)), 121), 10)
                    WHEN N'datetime' THEN CONVERT(varchar(30), CONVERT(datetime, LEAD(prv.[value]) OVER(ORDER BY p.PartitionID)), 121)
                    WHEN N'datetime2' THEN CONVERT(varchar(30), CONVERT(datetime2, LEAD(prv.[value]) OVER(ORDER BY p.PartitionID)), 121)
                    ELSE CONVERT(varchar(30), LEAD(prv.[value]) OVER(ORDER BY p.PartitionID))
                END
                , N''
            )                                               AS RightBoundaryStr            
            ,ppt.[name]                                     AS ParameterDataType

        FROM sys.partition_functions pf --information about partition function
        INNER JOIN sys.partition_parameters pp ON pp.function_id = pf.function_id AND pp.parameter_id = 1   --information about partition function parameter
        INNER JOIN sys.types ppt ON ppt.system_type_id = pp.system_type_id  --information about the parameter data type
        CROSS APPLY [Partitions] p 
        LEFT JOIN sys.partition_range_values prv ON prv.function_id = pf.function_id AND prv.boundary_id = p.PartitionID - 1 AND prv.parameter_id = 1
        WHERE
            pf.function_id = @pfID
    )
    SELECT
         pbd.PartitionFunctionName                                  AS PartitionFunctionName
        ,pbd.PartitionFunctionID                                    AS PartitionFunctionID
        ,pbd.Created                                                AS Created
        ,pbd.Modified                                               AS Modified
        ,pbd.ParameterDataType                                      AS ParameterDataType
        ,pbd.BoundaryType                                           AS BoundaryType
        ,pbd.PartitionID                                            AS PartitionID
        ,CASE 
            WHEN LeftBoundary IS NULL THEN NULL
            WHEN BoundaryType = 'RIGHT' THEN 'Y'
            ELSE 'N'
        END                                                         AS LeftBoundaryIncluded
        ,CASE 
            WHEN RightBoundary IS NULL THEN NULL
            WHEN BoundaryType = 'RIGHT' THEN N'N'
            ELSE N'Y'
        END                                                         AS RightBoundaryIncluded
        ,pbd.LeftBoundary                                           AS LeftBoundary
        ,pbd.RightBoundary                                          AS RightBoundary
        ,RIGHT(REPLICATE(' ', MAX(LEN(LeftBoundaryStr)) OVER())
         + LeftBoundaryStr, MAX(LEN(LeftBoundaryStr)) OVER())
        +
        CASE 
            WHEN LeftBoundary IS NULL THEN N'    '
            WHEN BoundaryType = 'RIGHT' THEN N' <= '
            ELSE N' <  '
        END 
        + N' [x] '
        +
        CASE 
            WHEN RightBoundary IS NULL THEN N'    '
            WHEN BoundaryType = 'RIGHT' THEN N' <  '
            ELSE N' <= '
        END 
        +
        ISNULL(RightBoundaryStr, N'')                               AS PartitionRange
    FROM PartitionBaseData pbd
    ORDER BY pbd.PartitionID

    IF @listDependencies = 1
    BEGIN
        RAISERROR(N'Retrieving information about depended partition schemes', 0, 0) WITH NOWAIT;
        --list depended partition schemes
        SELECT
             pf.[name]          AS PartitionFunctionName
            ,ps.[name]          AS PartitionSchemeName
            ,ps.data_space_id   AS PartitionScheme_data_space_id
            ,ps.function_id     AS PartitionFunctionID
        into #PS
        FROM sys.partition_schemes ps
        INNER JOIN sys.partition_functions pf ON pf.function_id = ps.function_id
        WHERE
            ps.function_id = @pfID

        IF EXISTS(SELECT 1 FROM #PS)
            SELECT * FROM #PS ORDER BY PartitionSchemeName
        
        RAISERROR(N'Retrieving information about depended objects (Tables and/or Indexed Views)', 0, 0) WITH NOWAIT;
        --list depended partitioned tables and partitioned views
        SELECT
             pf.[name]                  AS PartitionFunctionName
            ,SCHEMA_NAME(o.schema_id)   AS SchemaName
            ,o.[name]                   AS ObjectName
            ,o.object_id                AS ObjectID
            ,o.[type]                   AS ObjectType
            ,o.[type_desc]              AS ObjectTypeName
            ,o.create_date              AS Created
            ,o.modify_date              AS Modified
            ,i.[type_desc]              AS StorageType
            ,ps.[name]                  AS PartitionSchemeName
            ,ps.data_space_id           AS PartitionScheme_data_space_id
            ,ps.function_id             AS PartitionFunctionID
        INTO #PT
        FROM sys.objects o
        INNER JOIN sys.indexes i ON i.object_id = o.object_id AND i.index_id <= 1
        INNER JOIN sys.data_spaces ds on ds.data_space_id = i.data_space_id
        INNER JOIN sys.partition_schemes ps ON ds.data_space_id = ps.data_space_id
        INNER JOIN sys.partition_functions pf ON pf.function_id = ps.function_id
        WHERE ps.function_id = @pfID

        IF EXISTS(SELECT 1 FROM #PT)
            SELECT * FROM #PT ORDER BY SchemaName, ObjectName

        RAISERROR(N'Retrieving information about depended non clustered indexes', 0, 0) WITH NOWAIT;
        --list all nonclustered indexes
        SELECT
             pf.[name]                  AS PartitionFunctionName
            ,SCHEMA_NAME(o.schema_id)   AS SchemaName
            ,o.[name]                   AS ObjectName
            ,i.[name]                   AS IndexName
            ,o.object_id                AS ObjectID
            ,i.index_id                 AS IndexID
            ,i.[type]                   AS IndexType
            ,i.[type_desc]              AS IndexTypeName
            ,o.[type]                   AS ObjectType
            ,o.[type_desc]              AS ObjectTypeName
            ,ps.[name]                  AS PartitionSchemeName
            ,ps.data_space_id           AS PartitionScheme_data_space_id
            ,ps.function_id             AS PartitionFunctionID
        INTO #PI
        FROM sys.objects o
        INNER JOIN sys.indexes i ON i.object_id = o.object_id AND i.index_id > 1
        INNER JOIN sys.data_spaces ds on ds.data_space_id = i.data_space_id
        INNER JOIN sys.partition_schemes ps ON ds.data_space_id = ps.data_space_id
        INNER JOIN sys.partition_functions pf ON pf.function_id = ps.function_id
        WHERE ps.function_id = @pfID

        IF EXISTS(SELECT 1 FROM #PI)
            SELECT * FROM #PI ORDER BY SchemaName, ObjectName, IndexName

        DROP TABLE #PS;
        DROP TABLE #PT;
        DROP TABLE #PI;
    END
    RAISERROR(N'', 0, 0) WITH NOWAIT;
END
GO

--Mark Stored Procedure as system object, so it executes in the context of current database.
IF SERVERPROPERTY('EngineEdition') IN (1, 2, 3, 4, 8)
    EXEC(N'EXECUTE sp_ms_marksystemobject ''dbo.sp_HelpPartitionFunction''');
GO
GO